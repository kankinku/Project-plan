## Run/Iteration/Strategy ID 정책 (해시/버전/재현성)

- **문서 ID**: MOD-401
    
- **제목**: ID & Reproducibility Policy (Run/Iteration/Strategy/Artifact IDs)
    
- **버전**: 1.0
    
- **목표**: 동일한 전략/데이터/코드/정책이면 **언제 어디서 실행해도 같은 결과를 재현**할 수 있도록, 식별자(ID)·해시·버전·아티팩트 경로 규칙을 표준화한다. 또한 “같은 전략을 두 번 평가했는지”를 확실히 판별해 중복을 제거한다.
    
- **범위**: ID 종류/형식, 해시 입력(정규화 규칙), 버전 핀ning, calc_contract, 아티팩트 경로, 시드/결정성, 서명(옵션).
    
- **비범위**: Orchestrator 로직(MOD-400), Strategy Normalizer 구현(MOD-412)
    

---

## 1) 정책 원칙(Principles)

1. **불변(Immutable)**: 전략 스펙/계약/정책 버전은 기록 후 덮어쓰기 금지
    
2. **결정성(Deterministic)**: 같은 입력 → 같은 해시/ID → 같은 산출물 경로
    
3. **충돌 회피**: 해시는 충분히 긴 알고리즘(sha256) 사용
    
4. **인과 추적**: run→iteration→backtest→metrics→failure→constraint 연결이 1-hop으로 가능
    
5. **버전 핀ning**: 코드/데이터/정책/모델을 “문자열 버전”으로 고정하여 drift를 감지
    

---

## 2) ID 종류 및 형식

### 2.1 Run ID

- `run_id`: UUID v4 (또는 ULID)
    
- 생성 시점: run 시작(Orchestrator)
    
- 목적: 실행 세션 단위 식별
    

### 2.2 Iteration ID

- `iteration_id`: run 내 증가하는 int(0..)
    
- 목적: 루프 단계/제약 변화 시점 식별
    

### 2.3 Strategy ID (핵심)

- `strategy_id`: **Normalized Strategy Spec Hash**
    
- 계산: `sha256(canonical_json(normalized_spec))`
    
- 출력 형식: `strat_<first16hex>` (표시용) + 원본 sha256 전체는 DB 저장
    

### 2.4 Backtest ID

- `backtest_id`: UUID 또는 해시 기반 ID(권장: 해시 기반)
    
- 권장 계산:
    
    - `bt_id = sha256(strategy_id + data_version + period + engine_version + model_versions + calc_contract_hash)`
        
- 목적: “동일 조건 백테스트” 중복 제거
    

### 2.5 Artifact Bundle ID

- `bundle_id`: `bt_id` 기반
    
- 경로는 bt_id로 결정(아래 6절)
    

### 2.6 Failure ID / Constraint ID

- `failure_id`: UUID (생성 시각/내용에 따라 변할 수 있으므로 해시 고정은 비권장)
    
- `constraint_id`: UUID (단, 동일 constraint를 중복 생성 방지하려면 해시 키를 추가로 둠)
    
    - optional `constraint_key = sha256(type + scope + target + params_normalized)`
        

### 2.7 Scenario ID

- `scenario_id`: UUID
    
- optional `scenario_hash = sha256(raw_text + as_of + language)` (중복 감지)
    

---

## 3) Canonicalization 규칙(정규화/직렬화)

해시가 안정적이려면 JSON이 “항상 같은 문자열”로 직렬화되어야 한다.

### 3.1 canonical_json 규칙

- object key 정렬(사전순)
    
- float는 고정 정밀도(예: 소수 8자리)로 문자열화
    
- 리스트는 의미가 “집합”이면 정렬(예: feature_set, tags)
    
- 의미가 “순서”이면 유지(예: 단계형 rule chain)
    
- null/empty 제거 규칙을 명확히:
    
    - `omit_null_fields=true` 권장
        

### 3.2 normalized_spec 내용(예)

- 사용 피처/지표
    
- 연산자(>, <, AND, OR 등)
    
- 파라미터 값/범위(정확히)
    
- 실행 타이밍(next_bar)
    
- 리스크/청산 규칙(ATR 등)
    

> MOD-412가 normalized_spec을 생성하고, MOD-401은 “해시 입력 규격”을 고정한다.

---

## 4) 버전 핀ning(Version Pinning)

각 backtest 레코드에 아래 버전을 **필수**로 기록:

- `code_version`: git commit hash
    
- `schema_versions`: SCHEMA-3xx/OBS-5xx 버전
    
- `policy_versions`: score_v1, rules_v0, retriever_v1, scenario_quality_v1 등
    
- `engine_version`: backtest engine A/B 버전
    
- `model_versions`: cost_model, execution_model, portfolio_model 버전
    
- `data_version`: 데이터 스냅샷(벤더/업데이트 시각 포함)
    
- `universe_version`: 유니버스 정의 버전
    

---

## 5) calc_contract (재현성 계약)

calc_contract는 “어떤 방식으로 계산했는가”를 고정한다.

포함 항목(권장):

- 리샘플링/연율화 규칙
    
- 거래비용 모델 파라미터
    
- 슬리피지/스프레드 가정
    
- 체결 규칙(바 기준/지연)
    
- 포지션/현금/마진 규칙
    
- 결측 처리(NaN policy)
    

`calc_contract_hash = sha256(canonical_json(calc_contract))`

Backtest ID 생성에 **반드시 포함**.

---

## 6) 아티팩트 경로 규칙(Path Policy)

경로는 (run_id, strategy_id, backtest_id)로 결정.

권장:

```
artifacts/
  runs/<run_id>/
    strategies/<strategy_id>/
      backtests/<backtest_id>/
        data/metrics.json
        data/score.json
        data/trades.jsonl
        report/...
        analysis/...
```

- 덮어쓰기 금지:
    
    - 동일 backtest_id면 “이미 존재”로 간주하고 재사용 또는 스킵
        

---

## 7) 시드/결정성(Seeds & Determinism)

- `run_seed`: run 시작 시 64-bit seed 생성
    
- `iteration_seed = hash(run_seed + iteration_id)`
    
- `strategy_gen_seed = hash(iteration_seed + "GEN")`
    
- `sampler_seed = hash(iteration_seed + "SAMP")`
    

필수:

- 모든 랜덤 요소는 위 시드를 사용
    
- 시드/랜덤 라이브러리 버전까지 기록 가능하면 기록(권장)
    

---

## 8) 중복 감지(Deduplication)

- 동일 `strategy_id`는 전략 정의가 동일 → Generator에서 즉시 중복 제거
    
- 동일 `backtest_id`는 평가 조건이 동일 → Backtester 호출 스킵/캐시 활용
    
- constraint는 `constraint_key`로 중복 제거(선택)
    

---

## 9) 무결성/검증(Validation)

- 저장 시 해시 검증:
    
    - 파일 sha256(아티팩트) vs meta.sha256
        
- 재현성 검사:
    
    - Replay(MOD-483)에서 calc_contract_hash, code_version 불일치 시 drift로 기록
        

---

## 10) 예외/에러 처리

- `CANONICALIZE_FAIL`: 스펙에 비직렬화 객체 포함 → 저장/해시 생성 실패(전략 무효)
    
- `HASH_COLLISION_DETECTED`: 이론상 희박하지만, 감지 시 FULL_SHA를 키로 사용
    
- `VERSION_MISSING`: 필수 버전 누락 → backtest 저장 금지(FAILED_FATAL 권장)
    

---

## 11) 테스트 요구사항

1. 동일 normalized_spec이 항상 동일 strategy_id를 만드는지
    
2. key 순서/float 포맷 차이가 있어도 동일 해시가 나오는지(canonicalization)
    
3. calc_contract가 바뀌면 backtest_id가 반드시 바뀌는지
    
4. 동일 backtest_id면 아티팩트 경로가 동일하고 덮어쓰지 않는지
    
5. 시드 고정 시 전략 생성/샘플링이 동일 결과를 내는지
    

---

