## Strategy Normalizer & Hash (동치성, 정렬, 중복 제거)

- **문서 ID**: MOD-412
    
- **제목**: Strategy Normalizer & Hash Specification
    
- **버전**: 1.0
    
- **목표**: 의미가 같은 전략(DSL/AST)을 **동일 ID로 식별**하고, 대량 생성된 후보에서 **중복을 제거**해 탐색 비용을 줄인다.
    
- **범위**: SCHEMA-300(Strategy DSL)과 SCHEMA-310(Condition AST)의 정규화(canonicalization), 해시(strategy_id/condition_id), dedup 처리.
    
- **비범위**: Generator의 생성 로직(MOD-410), 파라미터 샘플링(MOD-411)
    

---

## 1) Normalizer 책임(Responsibilities)

1. **AST 정규화**(SCHEMA-310 규칙 준수): AND/OR 평탄화, 정렬, 중복 제거, 상수 축약(옵션)
    
2. **DSL 정규화**(SCHEMA-300): 키 정렬/메타 정리/숫자 표기 통일
    
3. **해시 계산**: `condition_id`, `strategy_id` 결정적 생성
    
4. **동치성(dedup)**: 동일 `strategy_id` 후보는 1개만 남김
    
5. **추적성**: 원본 → 정규화본 매핑 및 dedup 결과 기록(분석/디버그)
    

---

## 2) 입력/출력(Interface)

### 2.1 입력: `NormalizeRequest`

```json
{
  "run_id": "uuid",
  "iteration_id": 12,
  "candidates": [
    { "strategy_spec": { "...SCHEMA-300..." }, "provenance": { "mode": "atomic" } }
  ],
  "policy": {
    "ast_max_depth": 4,
    "ast_max_cmp": 8,
    "strip_metadata_fields": ["created_at", "notes"],
    "numeric_format": { "floats": "round(10)", "nan": "disallow" },
    "constant_folding": true
  }
}
```

### 2.2 출력: `NormalizeResponse`

```json
{
  "deduped": [
    {
      "strategy_id": "sha256_prefix",
      "strategy_spec_canonical": { "...SCHEMA-300 normalized..." },
      "condition_hashes": { "AST_ENTRY_1": "sha256", "AST_EXIT_1": "sha256" },
      "complexity": { "ast_depth": 3, "cmp_count": 6, "feature_count": 9 },
      "provenance": { "mode": "atomic" }
    }
  ],
  "stats": {
    "input_count": 1000,
    "schema_invalid": 35,
    "complexity_rejected": 120,
    "deduped_count": 640,
    "duplicates_removed": 205
  },
  "duplicate_map": [
    { "duplicate_of": "strat_A", "dropped_strategy_temp_id": "tmp_001", "reason": "SAME_STRATEGY_HASH" }
  ]
}
```

---

## 3) 정규화 파이프라인(Processing Pipeline)

### 3.1 단계 순서(권장)

1. **스키마 검증**
    
    - SCHEMA-300 유효성
        
    - SCHEMA-310 참조 무결성(conditions.ref 존재, feature key 존재)
        
2. **AST 정규화** (entry/filter/exit 등 모든 AST)
    
3. **DSL 정규화**
    
4. **복잡도 계산/제한 적용**
    
5. **해시 계산**
    
6. **Dedup(중복 제거)**
    
7. **정규화본 저장(선택)**
    

---

## 4) AST 정규화( SCHEMA-310 Canonicalization 준수 )

### 4.1 필수 규칙(반드시 적용)

- AND/OR 평탄화(flatten)
    
- children 정렬(sort by canonical key)
    
- 동일 child 중복 제거(dedup)
    

### 4.2 선택 규칙(정책으로 on/off)

- 상수 축약(constant folding)
    
    - AND에 FALSE 포함 → FALSE
        
    - OR에 TRUE 포함 → TRUE
        
- BETWEEN 변환
    
    - BETWEEN → (low<=x) AND (x<=high) 로 변환(또는 유지)
        

### 4.3 canonical key 정의(필수)

노드별 문자열 키를 만들고 AND/OR children 정렬에 사용.

- CMP: `CMP|left|op|right`
    
- IN: `IN|left|sorted(set)`
    
- BETWEEN: `BETWEEN|value|low|high|inclusive`
    
- NOT: `NOT|child_key`
    
- AND/OR: `AND|child1_key|child2_key|...`
    

---

## 5) DSL 정규화(Strategy Spec Canonicalization)

### 5.1 목표

“순서/불필요 메타/표기 차이”를 제거해 동일 의미 DSL → 동일 해시

### 5.2 필수 규칙

1. **JSON 키 정렬**: 모든 객체에 대해 sort keys
    
2. **불필요 메타 제거/화이트리스트화**
    
    - 제거 후보(기본): `metadata.created_at`, `metadata.notes`
        
    - **권장**: whitelist 기반으로 남길 필드만 유지
        
3. **수치 표기 통일**
    
    - float는 소수점 자릿수 고정(예: 10자리) 또는 문자열화 금지(숫자로 유지)
        
4. **conditions 블록은 “정규화된 AST”로 교체**
    
5. **빈 객체/빈 배열 처리 정책 고정**
    
    - 예: `reason_codes: []`는 유지(필드 존재 자체가 계약)
        

### 5.3 금지

- 정규화 과정에서 의미를 바꾸는 변환(예: 임계값 반올림으로 바꾸기) 금지
    
    - _표기만_ 통일(예: 3.0 vs 3.0000000000)
        

---

## 6) 복잡도 계산(Complexity Metrics)

Normalizer는 후보별 복잡도를 계산해 정책/제약에 사용한다.

### 6.1 계산 항목

- `ast_depth`: 최대 depth
    
- `cmp_count`: CMP 노드 총 개수(entry/filter/exit 합산)
    
- `feature_count`: AST에서 참조하는 feature key 유니크 개수
    
- `node_count_total`: 전체 노드 수(옵션)
    

### 6.2 적용 정책(예: 기본)

- `ast_depth <= 4`
    
- `cmp_count <= 8`
    
- `feature_count <= 12`
    

초과 시 `complexity_rejected`로 폐기(Generator가 만든 후보라도 여기서 최종 컷).

---

## 7) 해시/ID 생성 규칙(MOD-401 연동)

### 7.1 condition_id

- 입력: 정규화된 AST JSON
    
- 직렬화: canonical JSON(키 정렬 + 공백 제거)
    
- 해시: SHA-256(hex)
    
- 저장: `condition_hashes[ast_ref] = sha256`
    

### 7.2 strategy_id

- 입력: 정규화된 Strategy DSL JSON(conditions 정규화본 포함)
    
- 직렬화: canonical JSON
    
- 해시: SHA-256(hex)
    
- ID: prefix 사용 시 `sha256[:16]` 권장(충돌 위험 낮음), 전체 저장도 권장
    

---

## 8) Dedup(중복 제거) 규칙

### 8.1 기본

- 동일 `strategy_id`는 1개만 유지
    
- 유지 후보 선택 규칙(권장 우선순위)
    
    1. `provenance.mode` 우선순위(예: template > atomic > llm) _(정책)_
        
    2. 메타가 더 풍부한 것(예: reason_code 명시 등)
        
    3. 먼저 생성된 것(안정성)
        

### 8.2 duplicates 기록

- drop된 후보는 `duplicate_map`에 기록하여 “탐색 공간이 줄어든 근거”를 남김
    

---

## 9) Observability(로깅)

### 9.1 필수 통계(stats)

- schema_invalid 수
    
- complexity_rejected 수
    
- duplicates_removed 수
    
- mode별 생성/생존 비율(가능하면)
    

### 9.2 디버그 로그(선택)

- 특정 후보가 왜 reject되었는지 샘플 로그
    
- canonical JSON 해시 계산 전/후 길이 비교
    

---

## 10) 예외/에러 처리

- `SCHEMA_INVALID`: 필드 누락/참조 무결성 실패 → 후보 폐기
    
- `AST_INVALID_OPERATOR`: 허용되지 않은 op → 후보 폐기
    
- `NORMALIZATION_ERROR`: 내부 버그/직렬화 오류 → 후보 폐기 + iteration error rate 집계
    
- `HASH_COLLISION_SUSPECTED`: (거의 없지만) 동일 hash인데 canonical JSON이 다름 → CRITICAL, full hash 저장 및 중단 권장
    

---

## 11) 테스트 요구사항

### 11.1 단위 테스트

- AND children 순서만 다른 AST → 동일 condition_id
    
- AND 내부 중복 child 2개 → 1개로 정규화
    
- SCHEMA-300 key 순서가 다른 DSL → 동일 strategy_id
    
- metadata.notes만 다른 DSL → 동일 strategy_id(제거 정책일 때)
    

### 11.2 회귀 테스트

- strategy_id 충돌/변동이 생기면 즉시 탐지(버전업 시 hash 변동을 의도적으로 관리)
    
- 정규화 정책 변경 시 `schema_version` 또는 `normalizer_version`을 올리고 영향 범위를 리포트
    

---
