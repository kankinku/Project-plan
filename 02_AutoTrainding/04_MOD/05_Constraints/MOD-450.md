# MOD-450 — Constraint Writer (실패→제약 변환 규칙)

- **문서 ID**: MOD-450
    
- **제목**: Constraint Writer Specification (Failure → Constraint Translation)
    
- **버전**: 1.0
    
- **목표**: FailureRecord(MOD-440/441/442)를 입력으로 받아 “같은 실수를 반복하지 않도록” **제약(ConstraintSet, SCHEMA-330)** 을 자동 생성/강화/완화하는 규칙을 정의한다.
    
- **범위**: 입력/출력, 제약 생성 규칙(매핑 테이블), 제약 강도/수명, 충돌 해결, 안전장치(과도한 탐색 축소 방지).
    
- **비범위**: 제약을 실제로 적용하는 로직(MOD-451), 제약 수명 관리(MOD-452)
    

---

## 1) Constraint Writer 책임(Responsibilities)

1. **Failure → Constraint 변환**: 카테고리/태그별로 제약 타입을 선택하고 파라미터를 채움
    
2. **강도 조절**: severity/confidence/evidence 양에 따라 “약하게 힌트” vs “강하게 금지” 결정
    
3. **중복/충돌 처리**: 기존 ConstraintSet과 병합, 충돌 시 우선순위 규칙 적용
    
4. **과잉 수축 방지**: 제약이 탐색 공간을 과도하게 줄이면 일부는 “soft”로 전환
    
5. **추적성**: 어떤 실패가 어떤 제약을 만들었는지 provenance를 남김(회귀/해제에 필수)
    

---

## 2) 입력/출력(Interface)

### 2.1 입력: `WriteConstraintsRequest`

```json
{
  "run_id": "uuid",
  "iteration_id": 12,
  "strategy_id": "hash",

  "failure_records": [{ "...MOD-440..." }],

  "base_constraint_set": {
    "constraint_set_id": "cs_base",
    "constraints": []
  },

  "policy": {
    "max_new_constraints": 8,
    "min_confidence_to_harden": 0.75,
    "soft_default": true,
    "conflict_policy": "FAILSAFE_FIRST",
    "expiry": { "default_iterations": 20, "critical_iterations": 200 }
  }
}
```

### 2.2 출력: `WriteConstraintsResponse`

```json
{
  "constraint_set_delta": {
    "added": [{ "...SCHEMA-330 constraint..." }],
    "updated": [{ "...SCHEMA-330 constraint..." }],
    "disabled": []
  },
  "summary": {
    "new_constraints": 3,
    "hardened_constraints": 1,
    "soft_constraints": 2
  },
  "provenance": [
    { "failure_id": "uuid", "constraint_id": "c_101", "mapping_rule": "MAP_EXEC_SLIPPAGE_P95_HIGH" }
  ],
  "warnings": []
}
```

---

## 3) 제약 생성 원칙(Design Principles)

1. **안전 우선**: DATA/INFRA CRITICAL은 즉시 강한 제약(또는 중단 조건)
    
2. **최소 개입**: 한 번에 너무 많은 제약을 추가하지 않음(max_new_constraints)
    
3. **가장 영향 큰 원인부터**: confidence*severity 기준으로 상위 N개만 반영
    
4. **soft → hard 단계**: 처음엔 “힌트/우선순위”로 주고 반복 실패 시 harden
    
5. **되돌릴 수 있어야**: 모든 제약은 expiry/disable이 가능해야 함(=MOD-452)
    

---

## 4) 제약 타입(예시, SCHEMA-330 기반)

프로젝트에서 SCHEMA-330에 다음 타입(또는 유사)을 가진다고 가정한다.

- `BAN_FEATURES` / `ALLOW_FEATURES_ONLY`
    
- `BAN_OPERATORS` / `ALLOW_OPERATORS_ONLY`
    
- `MAX_COMPLEXITY` (ast_depth/cmp_count/feature_count)
    
- `LIMIT_PARAM_RANGE` (param min/max/step)
    
- `MIN_TRADE_COUNT` (탐색 단계 필터)
    
- `EXECUTION_CONSTRAINTS` (max_spread_bps, max_adv_participation, order_type_allowlist)
    
- `PORTFOLIO_CONSTRAINTS` (max_positions, sector_cap, max_position_weight)
    
- `STOP_DISTANCE_RULES` (min/max stop distance, atr_mult bounds 등)
    
- `REGIME_REQUIREMENT` (특정 레짐에서만 거래 허용/금지)
    

> 실제 enum은 SCHEMA-330에 맞춰 확정. 여기 문서는 “매핑 규칙”을 정의한다.

---

## 5) Failure Tag → Constraint 매핑 테이블(v0)

### 5.1 DATA (CRITICAL)

**MAP_DATA_LOOKAHEAD_DETECTED**

- when: `DATA + LOOKAHEAD_DETECTED`
    
- action:
    
    - `BAN_EXECUTION_TIMING_SAME_BAR` (또는 execution_timing 강제 = next_bar)
        
    - `BAN_FEATURES: ["future_return", ...]` (룩어헤드 원인이 feature일 때)
        
- hardness: HARD (즉시)
    
- expiry: long (critical_iterations)
    

**MAP_DATA_MISSING_HIGH**

- action(선택지):
    
    - `ALLOW_FEATURES_ONLY`로 핵심 피처만 사용(결측 낮은 피처 우선)
        
    - `LIMIT_UNIVERSE` (데이터 커버리지 낮은 심볼 제외)
        
- hardness: SOFT → 반복 시 HARD
    

---

### 5.2 EXECUTION

**MAP_EXEC_SLIPPAGE_P95_HIGH**

- when: `EXECUTION + SLIPPAGE_P95_HIGH`
    
- action 후보(우선순위):
    
    1. `EXECUTION_CONSTRAINTS.max_spread_bps` 하향 (예: 10→8)
        
    2. `EXECUTION_CONSTRAINTS.max_adv_participation` 하향 (예: 1%→0.5%)
        
    3. `EXECUTION_CONSTRAINTS.order_type_allowlist`에 LMT 우선(가능 시)
        
    4. `LIMIT_PARAM_RANGE`로 과도한 회전(턴오버) 유발 파라미터 축소(옵션)
        
- hardness:
    
    - confidence>=min_confidence_to_harden이면 HARD
        
    - 아니면 SOFT(가중치/선호만)
        
- expiry: default_iterations
    

**MAP_EXEC_REJECT_RATE_HIGH**

- action:
    
    - `EXECUTION_CONSTRAINTS` 완화가 아니라, 보통은 **유니버스/유동성 필터 강화**가 맞음
        
    - 예: `LIMIT_PARAM_RANGE`(min_avg_vol_60 상향) 또는 `MAX_SPREAD_BPS` 하향
        
- hardness: SOFT(초기), 반복 시 HARD
    

**MAP_EXEC_ADV_CAP_BINDING**

- action:
    
    - Generator 단계에서 “대형 주문/단기 회전”이 덜 나오게:
        
        - `PORTFOLIO_CONSTRAINTS.max_positions` 조정(분산)
            
        - `MAX_TURNOVER`(있다면) 또는 진입 빈도 제한(복잡도/조건 완화와 반대일 수도 있어 주의)
            
    - 실행 단계에서는 `max_adv_participation`을 올리면 체결은 되지만 현실성 악화 → 기본은 “올리지 않는다”
        
- hardness: SOFT
    

---

### 5.3 RISK_MODEL

**MAP_RISK_STOP_TOO_TIGHT_ATR**

- action:
    
    - `LIMIT_PARAM_RANGE: atr_mult` 상향 (예: min 2.5)
        
    - `STOP_DISTANCE_RULES.min_stop_pct` 상향(옵션)
        
- hardness: SOFT(오진 가능성이 있어 v0는 보수)
    

**MAP_RISK_DRAWDOWN_TOO_LARGE**

- action:
    
    - `PORTFOLIO_CONSTRAINTS.max_position_weight` 하향
        
    - `LEVERAGE_LIMIT` 하향
        
    - `MAX_POSITIONS` 상향(분산) 또는 섹터 캡 강화
        
- hardness: HARD(성과 위험이 크면)
    

---

### 5.4 PORTFOLIO

**MAP_PF_SECTOR_CONCENTRATION**

- action:
    
    - `PORTFOLIO_CONSTRAINTS.sector_cap` 강화(예: 30%→20%)
        
    - `MAX_CORR_CLUSTER` 같은 제약(있다면) 추가
        
- hardness: SOFT → 반복 시 HARD
    

---

### 5.5 TIMING / SIGNAL

**MAP_TIMING_OVER_FILTERING**

- action:
    
    - `MAX_COMPLEXITY` 더 낮춰서 “조건의 중복”을 줄이거나(AND 과다 억제)
        
    - 또는 특정 필터 atom/template에 대해 `BAN_TEMPLATE`/`BAN_ATOM`
        
- hardness: SOFT
    

**MAP_SIGNAL_OOS_DECAY**

- action(권장 v0: 직접 금지보다 “탐색 축소”):
    
    - 해당 template/atom에 `DEPRECATE_TEMPLATE` 플래그(=MOD-413 status 조정)
        
    - `MAX_COMPLEXITY` 낮추기(과적합 줄이기)
        
    - 파라미터 범위를 중앙으로 수축(LIMIT_PARAM_RANGE tighten)
        
- hardness: SOFT(오진 방지), 반복 시 HARD
    

---

## 6) 강도(hardness) 결정 로직

Constraint 객체에 `hardness: SOFT|HARD`를 둔다(또는 weight/priority로 표현).

권장:

- CRITICAL: HARD 즉시
    
- ERROR:
    
    - confidence>=0.75 → HARD
        
    - else SOFT
        
- WARN: SOFT
    

---

## 7) 병합/충돌 해결(Conflict Resolution)

기존 ConstraintSet과 병합 시:

### 7.1 동일 타입/대상

- `LIMIT_PARAM_RANGE`는 범위를 **교집합**으로 축소(단, empty면 충돌)
    
- `MAX_*`는 더 엄격한 값 선택(작은 값)
    
- allowlist/banlist는 policy에 따라:
    
    - FAILSAFE_FIRST: ban이 우선
        

### 7.2 충돌(빈 교집합 등)

- 충돌 시:
    
    - 새 제약을 SOFT로 내리거나
        
    - “경고만 남기고” 적용하지 않음
        
- warnings에 `CONSTRAINT_CONFLICT` 기록(중요)
    

---

## 8) 수명/만료(Expiry)

- 모든 새 제약은 `expires_after_iterations`를 갖는다.
    
- 기본: 20 iterations
    
- CRITICAL: 200 iterations 또는 manual release
    
- 만료되면 MOD-452가 자동 비활성/회귀 테스트 수행
    

---

## 9) 출력/추적(Provenance)

각 제약에는 반드시 provenance를 남긴다:

- source_failure_id
    
- rule_id (MAP_*)
    
- created_at_run/iteration
    
- confidence/severity snapshot
    

이게 있어야 “왜 이 제약이 생겼는지”를 KB에서 설명 가능.

---

## 10) 테스트 요구사항

- LOOKAHEAD_DETECTED → 항상 execution_timing 강제/금지 제약 생성(HARD)
    
- SLIPPAGE_P95_HIGH → max_spread_bps/adv cap 제약 생성(soft/hard가 confidence로 결정)
    
- LIMIT_PARAM_RANGE 병합 시 교집합 계산이 맞는지
    
- max_new_constraints가 초과되지 않는지(상위 우선순위만 남기기)
    
- 충돌 발생 시 적용 스킵 + warnings 기록되는지
    

---
