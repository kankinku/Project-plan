## Constraint Lifecycle (활성/비활성/만료/회귀 테스트)

- **문서 ID**: MOD-452
    
- **제목**: Constraint Lifecycle Specification (Enable/Disable/Expiry/Regression)
    
- **버전**: 1.0
    
- **목표**: 제약(ConstraintSet, SCHEMA-330)이 시간이 지나면서 “과도하게 탐색을 막거나”, “이미 해결된 문제를 계속 막는” 상황을 피하기 위해, 제약의 **활성/비활성/만료/회귀 테스트/승격·강등** 운영 규칙을 정의한다.
    
- **범위**: 제약 상태 모델, 만료 정책, 회귀 테스트(rollback/compare), 자동 harden/relax 규칙, 감사 로그.
    
- **비범위**: 제약 생성(MOD-450), 제약 적용(MOD-451)
    

---

## 1) Lifecycle 책임(Responsibilities)

1. **상태 관리**: 제약을 ACTIVE/INACTIVE/EXPIRED 등으로 관리
    
2. **만료(Expiry)**: iteration 기반(또는 시간 기반) 자동 만료/재평가
    
3. **회귀 테스트**: 제약 적용 전/후 성능과 실패 재발 여부를 비교
    
4. **강화/완화**: 반복 실패 시 harden, 개선되면 relax/disable
    
5. **감사 로그(Audit)**: “왜 언제 어떤 제약이 바뀌었는지”를 남김(KB 축적)
    

---

## 2) 제약 상태 모델(State)

### 2.1 ConstraintState enum

- `ACTIVE`: 적용 중
    
- `INACTIVE`: 저장은 되어 있으나 적용 안 함(수동/자동)
    
- `EXPIRED`: 만료되어 적용 안 함(기본적으로 inactive와 다르며, 재평가 대상)
    
- `DEPRECATED`: 더 이상 사용하지 않음(정책 변경/오진)
    
- `OVERRIDDEN`: 상위 정책/사용자 설정으로 덮여 적용 안 함
    

### 2.2 필수 메타데이터

각 constraint에 다음 필드를 유지(정형 DB 추천):

- `constraint_id`
    
- `constraint_set_id`
    
- `state`
    
- `hardness` (SOFT/HARD)
    
- `created_at_run/iteration`
    
- `expires_at_iteration`
    
- `source_failure_ids[]`
    
- `last_evaluated_iteration`
    
- `hit_count` (얼마나 자주 발동/차단했는지)
    
- `effectiveness_score` (회귀 결과 기반)
    

---

## 3) 만료 정책(Expiry Policy)

### 3.1 기본 규칙

- SOFT 제약:
    
    - `expires_after_iterations = 20` (예)
        
- HARD 제약:
    
    - `expires_after_iterations = 60`
        
- CRITICAL(룩어헤드/인프라 붕괴):
    
    - `expires_after_iterations = 200` 또는 “수동 해제만”
        

### 3.2 만료 시 동작

- state를 `EXPIRED`로 전환
    
- 자동으로 “재평가 큐”에 넣음(Orchestrator가 처리)
    
- EXPIRED 상태에서는 기본 적용 안 함(단, FAILSAFE 정책이면 일부 적용 가능)
    

---

## 4) 회귀 테스트(Regression Test)

### 4.1 목적

- “이 제약이 성능을 개선했는가?”
    
- “문제가 재발하지 않도록 막았는가?”
    
- “탐색 공간을 너무 줄여서 더 나쁜가?”
    

### 4.2 회귀 테스트 방식(권장 2가지)

**A) A/B 재실행(강함, 비용 큼)**

- 동일 전략군/유사 전략 샘플을:
    
    - constraints ON vs OFF로 backtest(B) 비교
        
- 비교 항목:
    
    - 재발 실패(tag) 빈도 감소
        
    - score_total 상승 여부
        
    - trade_count/coverage 감소 여부(과필터링 경고)
        

**B) 로그 기반 대체(약함, 비용 낮음)**

- constraint hit_count, blocked_count, trade_count 변화, reject_rate 변화로 추정
    
- 성능 지표는 “대표 후보” 몇 개만 재검증
    

### 4.3 회귀 대상 선정(샘플링)

- hit_count가 높은 제약 우선(가장 영향 큼)
    
- severity/confidence 높은 failure에서 온 제약 우선
    
- max N개/iteration으로 제한(리소스 보호)
    

---

## 5) 효과성 점수(Effectiveness Score)

제약별로 0~1 점수로 “효과”를 저장한다.

예(권장):

```text
effectiveness =
  0.5 * (failure_recurrence_reduction) +
  0.3 * (score_improvement_norm) +
  0.2 * (search_space_preservation)
```

- failure_recurrence_reduction: 해당 tag 재발률 감소(좋으면 ↑)
    
- score_improvement_norm: ON 대비 OFF 점수 개선(좋으면 ↑)
    
- search_space_preservation: trade_count/후보수 감소가 과도하지 않으면 ↑
    

---

## 6) 자동 harden/relax 규칙

### 6.1 Harden (SOFT → HARD)

조건(예):

- 동일 tag 실패가 최근 K iterations 중 N회 발생
    
- 또는 제약 hit_count는 높은데 성과 개선이 확인됨
    

예 규칙:

- `if recurrence(tag) >= 3 and confidence_avg >= 0.7 => HARDEN`
    

### 6.2 Relax/Disable (HARD → SOFT 또는 INACTIVE)

조건(예):

- 효과성 점수 낮음(예: <0.3)
    
- trade_count/coverage를 과도하게 감소시킴
    
- 해당 failure가 장기간 재발하지 않음
    

예 규칙:

- `if effectiveness < 0.3 for 2 evals => relax`
    
- `if no recurrence for 100 iterations => disable`
    

### 6.3 Deprecate (오진/정책 변경)

- taxonomy/rule이 변경되어 더 이상 유효하지 않음
    
- 새 제약이 상위에서 대체함(OVERRIDDEN → DEPRECATED 가능)
    

---

## 7) 충돌/우선순위 재조정

- 여러 제약이 겹쳐 탐색이 막히면:
    
    - **hit_count 상위 1~2개만 유지**, 나머지는 SOFT로 내리거나 EXPIRED 처리
        
- “안전 관련(DATA/INFRA)” 제약은 항상 우선(FAILSAFE)
    

---

## 8) 감사 로그(Audit Log)

Lifecycle 이벤트는 반드시 로그로 남긴다(정형+비정형 모두 가능).

예 이벤트:

- `CONSTRAINT_CREATED`
    
- `CONSTRAINT_HARDENED`
    
- `CONSTRAINT_RELAXED`
    
- `CONSTRAINT_EXPIRED`
    
- `CONSTRAINT_DISABLED`
    
- `CONSTRAINT_OVERRIDDEN`
    
- `CONSTRAINT_DEPRECATED`
    

필드(권장):

- time, run_id, iteration_id, constraint_id
    
- from_state → to_state
    
- reason(정책/규칙/사람 입력)
    
- evidence refs(간단)
    

---

## 9) 예외/에러 처리

- `MISSING_BASELINE`: OFF 비교 기준이 없음 → 회귀를 건너뛰고 WARN
    
- `BUDGET_EXCEEDED`: 회귀 테스트 예산 초과 → 다음 iteration으로 연기(동기 처리 내에서 “스킵”)
    
- `CONSTRAINT_STATE_INVALID`: 불가능한 전이(예: DEPRECATED→ACTIVE) → FAIL
    

---

## 10) 테스트 요구사항

- expires_at_iteration 도달 시 EXPIRED로 전환되는지
    
- 재발(tag) 카운트가 조건을 만족하면 SOFT→HARD로 바뀌는지
    
- effectiveness 낮으면 HARD→SOFT/INACTIVE로 완화되는지
    
- 안전 제약(DATA/INFRA)이 다른 제약보다 우선 적용되는지
    
- audit log가 모든 전이에 대해 남는지
    

---
