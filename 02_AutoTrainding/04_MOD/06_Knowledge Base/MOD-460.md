## Local DB (정형: 전략/결과/실패/제약)

- **문서 ID**: MOD-460
    
- **제목**: Local DB Specification (Structured Knowledge Store)
    
- **버전**: 1.0
    
- **목표**: 전략 생성→백테스트→스코어링→실패분석→제약까지의 전 과정을 **정형 데이터로 저장**하여, 재현성/검색/통계/회귀/승격을 가능하게 한다. (비정형 문서/리포트는 MOD-461)
    
- **범위**: 데이터 모델(테이블/레코드), 키 정책, 인덱스, 저장/조회 인터페이스, 마이그레이션/버전, 무결성 규칙.
    
- **비범위**: 비정형 문서 저장(MOD-461), 유사 검색 엔진(MOD-462), 실제 DBMS 선택/운영 세부(단, 권장안은 포함)
    

---

## 1) Local DB 책임(Responsibilities)

1. **단일 진실의 원천(SoT)**: 전략/런/결과/실패/제약의 canonical 레코드 보관
    
2. **재현성 보장**: run/iteration/strategy_id + data_version + model_version을 함께 저장
    
3. **추적성**: “어떤 실패가 어떤 제약을 만들었는지”, “어떤 템플릿이 승격됐는지” 연결
    
4. **검색/집계**: 상위 전략 조회, 반복 실패 패턴 통계, 제약 효과성 평가 데이터 제공
    
5. **다른 스토어 연결**: 아티팩트 경로(MOD-433), 문서 스토어(MOD-461) ref를 관리
    

---

## 2) 저장소 선택(권장)

- MVP: **SQLite** (로컬 단일 파일, 빠른 개발)
    
- 성장: **PostgreSQL** (동시성/확장/인덱싱)
    
- 시계열/대용량 로그는 파일(parquet/jsonl)로 두고, DB에는 **경로+요약+인덱스**만 저장(권장)
    

---

## 3) 키/식별자 정책(Key Policy)

- `run_id`: UUID
    
- `iteration_id`: int (run 내 증가)
    
- `strategy_id`: **정규화된 전략 해시** (MOD-412)
    
- `template_id`, `atom_id`: MOD-413 규격
    
- `constraint_set_id`, `constraint_id`: UUID 또는 prefixed id
    
- `data_version`, `engine_version`, `model_version`: 문자열(불변)
    

**중요**: 모든 결과 레코드는 `(strategy_id, data_version, engine_version, model_versions, calc_contract_hash)` 조합으로 재현 가능해야 함.

---

## 4) 핵심 테이블(권장 스키마)

아래는 “필수 MVP” 테이블 + “확장” 테이블로 나눈다.

---

## 4.1 필수(MVP)

### 4.1.1 `runs`

- 목적: 실행(run) 단위 메타
    
- 주요 컬럼:
    
    - run_id (PK)
        
    - created_at, project_version
        
    - config_json (전체 run 설정 스냅샷)
        
    - status (RUNNING/DONE/FAILED)
        

### 4.1.2 `iterations`

- 목적: run 내 반복 단계 기록
    
- 컬럼:
    
    - run_id, iteration_id (PK)
        
    - started_at, ended_at
        
    - constraint_set_id_applied
        
    - summary_json (iteration 요약)
        

### 4.1.3 `strategies`

- 목적: 전략 정의(불변)
    
- 컬럼:
    
    - strategy_id (PK)
        
    - normalized_spec_json (SCHEMA-300 정규화 결과)
        
    - created_from (template_id/llm/import 등)
        
    - created_at
        
    - spec_hash_version (MOD-412 version)
        

### 4.1.4 `backtests`

- 목적: 특정 전략의 백테스트 실행 레코드
    
- 컬럼:
    
    - backtest_id (PK)
        
    - run_id, iteration_id, strategy_id (FK)
        
    - engine_mode (A/B)
        
    - data_version, universe_version, period_start, period_end, bar_interval
        
    - model_versions_json (cost/exec/pf)
        
    - calc_contract_json
        
    - status, error_code
        
    - artifacts_dir (파일 경로)
        

### 4.1.5 `metrics`

- 목적: SCHEMA-340 metrics 요약(핵심 값 + 원문 경로)
    
- 컬럼:
    
    - backtest_id (PK/FK)
        
    - score_key_metrics (CAGR, Sharpe, MaxDD 등) 컬럼화 + metrics_json_path
        
    - quality_warnings_json
        

### 4.1.6 `scores`

- 목적: MOD-431 점수 결과
    
- 컬럼:
    
    - backtest_id (PK/FK)
        
    - score_total
        
    - breakdown_json
        
    - passed (bool)
        
    - fail_reasons_json
        
    - policy_version
        

### 4.1.7 `failures`

- 목적: MOD-440 FailureRecord 저장(정형화)
    
- 컬럼:
    
    - failure_id (PK)
        
    - backtest_id (FK)
        
    - category
        
    - tags_json
        
    - severity
        
    - confidence
        
    - summary
        
    - evidence_pack_path
        
    - state (OPEN/CONFIRMED/RESOLVED/DEPRECATED)
        
    - created_at
        

### 4.1.8 `constraint_sets`

- 목적: iteration마다 적용되는 제약 묶음
    
- 컬럼:
    
    - constraint_set_id (PK)
        
    - created_at
        
    - base_constraint_set_id (nullable)
        
    - constraints_json (SCHEMA-330 원문)
        
    - policy_version
        
    - state (ACTIVE/ARCHIVED)
        

### 4.1.9 `constraint_provenance`

- 목적: failure → constraint 매핑 추적
    
- 컬럼:
    
    - id (PK)
        
    - constraint_set_id
        
    - constraint_id
        
    - failure_id
        
    - mapping_rule
        
    - created_at_iteration
        

---

## 4.2 확장(권장)

### 4.2.1 `templates` / `atoms`

- MOD-413 라이브러리 레지스트리
    
- tier/status/confidence/usage_count 등
    

### 4.2.2 `robustness_cases`

- MOD-432 케이스별 결과
    
- case_id, type, params_json, metrics_ref, passed
    

### 4.2.3 `reports`

- MOD-433 생성물 경로
    
- tearsheet_pdf_path, summary_json_path, doc_store_id
    

### 4.2.4 `live_trades` / `replays`

- 라이브 운영(추후)
    
- 실시간 체결/리플레이 연결
    

---

## 5) 인덱스 설계(핵심)

- metrics/scores 조회가 많으므로:
    
    - `scores(score_total DESC)`
        
    - `metrics(sharpe_net DESC)`, `metrics(max_drawdown_net ASC)`
        
- 실패 분석용:
    
    - `failures(category)`, `failures(severity)`
        
    - tags는 JSON이므로:
        
        - PostgreSQL이면 GIN index 권장
            
        - SQLite면 별도 `failure_tags(failure_id, tag)` 테이블로 정규화 권장
            
- 재현성 키:
    
    - `backtests(strategy_id, data_version, engine_mode, period_start, period_end)`
        

---

## 6) 무결성(Integrity) 규칙

1. `strategies.normalized_spec_json`은 immutable
    
2. `metrics`는 반드시 해당 `backtests`의 calc_contract를 echo해야 함
    
3. `scores.backtest_id`는 `metrics.backtest_id` 존재를 전제로 함
    
4. `failures`는 반드시 `evidence_pack_path` 또는 최소 evidence json을 가져야 함
    
5. `constraint_provenance`는 존재하는 failure/constraint_id만 참조
    

---

## 7) 저장/조회 API(개념)

- `db.upsert_strategy(strategy_id, spec_json)`
    
- `db.insert_backtest(run_id, iteration_id, strategy_id, config...) -> backtest_id`
    
- `db.save_metrics(backtest_id, metrics_json_path, key_metrics)`
    
- `db.save_score(backtest_id, score_response)`
    
- `db.save_failures(backtest_id, failure_records[])`
    
- `db.save_constraint_set(iteration_id, constraints_json, provenance[])`
    

---

## 8) 마이그레이션/버전

- `schema_migrations` 테이블로 DB 스키마 버전 관리
    
- 각 레코드에:
    
    - `schema_version`(SCHEMA-340 등)
        
    - `policy_version`(score_v1, rules_v0 등)
        
    - `engine_version`, `model_version`
        
    - `code_version`(git commit hash 권장)
        

---

## 9) 테스트 요구사항

- foreign key 무결성(삭제/변경 방지)
    
- 동일 전략/동일 데이터/동일 계약으로 backtest를 2번 저장해도 중복/충돌 정책이 일관적인지(업서트/유니크키)
    
- failure → constraint provenance가 누락되지 않는지
    
- tags 인덱싱(또는 정규화 테이블)로 “반복 실패 Top N” 조회가 가능한지
    

---
