## Scenario Parser (NL → JSON)

- **문서 ID**: MOD-470
    
- **제목**: Scenario Parser Specification (Natural Language → Structured JSON)
    
- **버전**: 1.0
    
- **목표**: 사용자가 입력한 “앞으로 일어날 일에 대한 가설/시나리오(자연어)”를 **검증 가능한 구조(JSON)** 로 변환하여, (1) 품질 평가(MOD-471) (2) 전략 반영/스트레스(MOD-472) (3) KB 축적(MOD-460/461) 이 가능하게 한다.
    
- **범위**: 파싱 규칙, 엔티티 추출(자산/기간/이벤트), 주장 구조화(조건/기대 방향/검증), 불확실성 표현, 출력 스키마.
    
- **비범위**: 시나리오 타당성 점수화(MOD-471), 실제 전략 반영 로직(MOD-472)
    

---

## 1) Parser 책임(Responsibilities)

1. **구조화**: 자유 텍스트 → 표준 Scenario JSON으로 변환
    
2. **엔티티 추출**: 자산(티커/심볼), 시장(지수/섹터), 이벤트(발표/정책), 기간(시작/끝/호라이즌)
    
3. **주장/조건 분해**: “A이면 B가 C한다” 형태로 조건/기대효과/관측지표로 쪼갬
    
4. **검증 가능성 확보**: 관측 변수(가격/지표/거시지표 등)와 **falsifier(반증 조건)** 를 구조로 남김
    
5. **불확실성 기록**: 파싱 confidence, unknown 필드, 모호함 플래그 기록(추후 MOD-471에서 감점)
    

---

## 2) 입력/출력(Interface)

### 2.1 입력: `ScenarioParseRequest`

```json
{
  "scenario_id": "uuid-optional",
  "user_text": "자연어 시나리오 원문",
  "language": "ko|en|auto",
  "as_of": "2026-02-06",
  "context": {
    "asset_class": "equity|crypto|fx|futures|mixed|unknown",
    "default_horizon_days": 30,
    "timezone": "Asia/Seoul"
  },
  "policy": {
    "allow_ambiguous": true,
    "max_hypotheses": 5,
    "normalize_units": true
  }
}
```

### 2.2 출력: `ScenarioParseResponse`

```json
{
  "scenario_id": "uuid",
  "schema_version": "SCHEMA-SCENARIO-470",
  "raw": {
    "text": "원문",
    "language": "ko",
    "as_of": "2026-02-06"
  },

  "hypotheses": [
    {
      "id": "H1",
      "category": "macro|earnings|policy|industry|technical|sentiment|other",
      "statement": "요약된 주장 1문장",
      "horizon": { "type": "days|weeks|date_range|unknown", "value": 30, "start": null, "end": null },

      "assets": [
        { "symbol": "AAPL", "type": "ticker|index|crypto|unknown", "role": "target|driver|hedge", "confidence": 0.8 }
      ],

      "expected_moves": [
        { "symbol": "AAPL", "direction": "up|down|range|vol_up|vol_down|unknown", "magnitude": { "type":"pct|bps|atr|unknown", "value": 5 } }
      ],

      "conditions": [
        { "type": "event|threshold|time|other", "field": "CPI_YoY", "op": "<=", "value": 3.0, "unit": "%", "confidence": 0.6 }
      ],

      "observables": [
        { "field": "price_return", "symbol": "AAPL", "window": "30d", "metric": "pct", "target": "+5%", "confidence": 0.7 }
      ],

      "falsifiers": [
        { "field": "price_return", "symbol": "AAPL", "window": "30d", "op": "<", "value": -3, "unit": "%", "confidence": 0.6 }
      ],

      "assumptions": ["전제1", "전제2"],
      "risk_notes": ["리스크 요인"],
      "parse_confidence": 0.72,
      "ambiguities": ["기간이 모호함", "대상 자산이 불명확함"]
    }
  ],

  "parse_meta": {
    "entity_extraction": { "symbols_found": ["AAPL"], "dates_found": [], "numbers_found": [5, 3.0] },
    "warnings": []
  }
}
```

---

## 3) Scenario JSON 스키마(핵심 규칙)

### 3.1 필수 원칙

- **원문(raw.text)은 항상 보존** (재현/감사/재파싱)
    
- hypotheses는 **최대 N개**(policy.max_hypotheses)
    
- 모든 숫자는 가능하면 **단위(normalize_units)** 를 포함
    
- 확정 못 하면 `unknown` + `ambiguities[]`에 사유 기록
    

### 3.2 최소 필수 필드(각 hypothesis)

- `statement`
    
- `horizon`
    
- `assets[]`(없으면 unknown asset 1개라도 넣고 confidence 낮게)
    
- `expected_moves[]`(없으면 direction=unknown)
    
- `observables[]` 또는 `falsifiers[]` 중 최소 1개는 생성 시도
    

---

## 4) 파싱 단계(Behavior Pipeline)

1. **전처리**
    

- 언어 감지, 문장 분리, 숫자/날짜/단위 정규화(“한달”→30d 등)
    

2. **엔티티 추출**
    

- 티커/심볼 후보(대문자 토큰, 사용자 표기, 사전 기반)
    
- 지표/이벤트 키워드(금리, CPI, 실적, 규제, ETF 승인 등)
    
- 시간 표현(“다음주”, “3개월 내”) → horizon 추정
    

3. **주장 분해**
    

- causal/conditional 패턴(“~하면 ~한다”, “~때문에 ~상승”)을
    
    - conditions / expected_moves / risk_notes로 분배
        

4. **검증가능 형태로 변환**
    

- 기대를 observables로 바꾸고,
    
- 가능한 범위에서 **falsifier(반증)** 생성(없으면 ambiguities에 기록)
    

5. **confidence 부여**
    

- 엔티티/기간/방향/수치가 모두 명확할수록 ↑
    
- unknown/모호/상충 문장 많을수록 ↓
    

---

## 5) 상태(State)

- `RECEIVED` → `PARSED` → `STORED`
    
- 부분 성공 시: `PARSED_WITH_AMBIGUITY`
    
- 실패 시: `FAILED` (단, v1은 최대한 “unknown”으로라도 PARSED 반환을 목표)
    

---

## 6) 로깅/저장(Observability & Persistence)

### 6.1 Document Store 저장(MOD-461)

- `SCENARIO_INPUT_JSON`: 원문+메타
    
- `SCENARIO_PARSED_JSON`: 파싱 결과(=ScenarioParseResponse)
    

### 6.2 Local DB 연동(MOD-460 확장 권장)

- `scenarios` 테이블(확장):
    
    - scenario_id, run_id(optional), created_at, raw_text_hash, parsed_json_path, tags, parse_confidence
        

---

## 7) 예외/에러 처리

- `EMPTY_INPUT`: user_text 비어있음 → FAILED
    
- `LANG_DETECT_FAIL`: language=auto인데 실패 → ko로 fallback + WARN
    
- `ENTITY_PARSE_FAIL`: 티커/기간 추출 실패 → unknown 처리 + WARN
    
- `CONFLICTING_CLAIMS`: 방향/기간이 상충 → hypotheses 분리 또는 ambiguity 기록
    

에러/경고는 `parse_meta.warnings[]`에 누적.

---

## 8) 테스트 요구사항

1. **결정성**: 동일 입력+정책이면 동일 JSON(허용 오차 없이)
    
2. **엔티티 추출**: 티커/기간/수치 추출 케이스 통과
    
3. **unknown 안전성**: 정보가 부족해도 PARSED_WITH_AMBIGUITY로 반환(크래시 금지)
    
4. **반증 생성**: 방향/기간이 있으면 falsifier가 생성되는지(없으면 ambiguity에 남는지)
    
5. **저장 경로**: docstore 경로 규격대로 생성되는지(MOD-461)
    

---
