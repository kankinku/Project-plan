## Scenario Quality Scoring (명확성/검증가능성/일관성)

- **문서 ID**: MOD-471
    
- **제목**: Scenario Quality Scoring Specification
    
- **버전**: 1.0
    
- **목표**: MOD-470에서 생성된 Scenario JSON이 “전략에 반영할 가치가 있는지”를 **정량 평가**한다. 즉, 시나리오의 **명확성·검증가능성·일관성·실행가능성(데이터/시간)** 을 점수화하고, 낮은 품질 시나리오는 “soft 반영 제한” 또는 “추가 질문 필요”로 라우팅한다.
    
- **범위**: 품질 항목 정의, 점수 산출(0~100), 결격(FAIL) 조건, 출력 스키마, 로그/저장.
    
- **비범위**: 시나리오를 실제로 전략에 반영하는 로직(MOD-472)
    

---

## 1) Quality Scoring 책임(Responsibilities)

1. **품질 점수 산출**: overall_score + sub_scores(clarity/verify/consistency/actionability)
    
2. **결격/게이트**: 반영 불가 수준이면 `passed=false` 반환
    
3. **개선 가이드 생성**: “무엇이 부족한지”를 fix_suggestions로 반환(대화/UX용)
    
4. **반영 강도 제안**: integration_policy_hint(soft weight cap, stress only 등) 제공
    
5. **KB 축적**: 평가 결과를 Document Store/Local DB에 저장
    

---

## 2) 입력/출력(Interface)

### 2.1 입력: `ScenarioQualityRequest`

```json
{
  "scenario_id": "uuid",
  "parsed_scenario": { "...SCHEMA-SCENARIO-470..." },

  "policy": {
    "score_scale": "0_100",
    "min_overall_to_integrate": 60,
    "min_verify_to_integrate": 50,

    "weights": {
      "clarity": 0.30,
      "verifiability": 0.35,
      "consistency": 0.20,
      "actionability": 0.15
    },

    "gates": {
      "require_asset": true,
      "require_horizon": true,
      "require_observable_or_falsifier": true,
      "max_ambiguities": 5
    }
  }
}
```

### 2.2 출력: `ScenarioQualityResponse`

```json
{
  "scenario_id": "uuid",
  "passed": true,

  "overall_score": 74,
  "sub_scores": {
    "clarity": 70,
    "verifiability": 78,
    "consistency": 65,
    "actionability": 80
  },

  "issues": [
    { "code": "AMBIGUOUS_ASSET_ROLE", "severity": "WARN", "details": "driver/target 구분 불명확" }
  ],

  "fix_suggestions": [
    "대상 자산(매수/매도 후보)을 1~3개로 명시해줘.",
    "검증 기준(예: 30일 수익률 +5% 이상)을 숫자로 적어줘."
  ],

  "integration_policy_hint": {
    "mode": "soft|stress_only|block",
    "scenario_weight_cap": 0.4,
    "required_stress_tests": ["regime_split", "cost_stress"]
  }
}
```

---

## 3) 품질 항목 정의(Scoring Dimensions)

## 3.1 Clarity (명확성)

**무엇을 말하는지**가 분명한가?

평가 신호(예):

- assets에 target symbol 존재(unknown 아니면 가점)
    
- horizon이 명시(days/weeks/date_range)
    
- expected_moves에 direction이 up/down/range 등으로 명확
    
- magnitude(크기)가 수치로 존재하면 추가 가점
    
- ambiguities 개수 많으면 감점
    

---

## 3.2 Verifiability (검증가능성)

**반증 가능(falsifiable)** 인가?

평가 신호:

- observables 존재(관측 변수, 윈도우, 지표)
    
- falsifiers 존재(반증 조건)
    
- 관측 가능한 데이터 필드(가격/거래량/금리/CPI 등) 사용
    
- “언젠가 오를 것” 같은 모호한 표현(unknown) 감점
    
- time window 없으면 크게 감점
    

---

## 3.3 Consistency (일관성)

내부 상충이 없는가?

평가 신호:

- 동일 hypothesis 내에서 방향(up/down)이 충돌하면 감점
    
- 기간이 서로 다르면 분리되었는지(분리되면 감점 완화)
    
- condition이 expected move와 논리적으로 완전히 무관하면 감점(약하게)
    
- parse_meta에서 CONFLICTING_CLAIMS 경고가 있으면 감점
    

---

## 3.4 Actionability (반영가능성)

전략 반영/스트레스가 가능한가?

평가 신호:

- target/driver 역할이 구분됨
    
- “어떤 전략 형태로 반영할지”가 힌트가 있음(예: 변동성 상승 → 옵션/포지션 축소/ATR 확장)
    
- 적용 자산군/시장(주식/코인) 명시
    
- 검증 데이터가 프로젝트 데이터 파이프라인에 존재하면 가점(없으면 감점)
    

---

## 4) 점수 산출 방식(권장)

### 4.1 hypothesis별 점수 → 전체 점수

- hypotheses가 여러 개면:
    
    - 상위 1~2개(가장 명확한 가설)에 가중치를 높임
        
    - 너무 많은 hypothesis는 품질 저하로 간주(패널티)
        

예:

- `overall = Σ(weight_i * score_i)` (i는 top hypotheses)
    

### 4.2 sub_score 계산(예시 룰 기반)

- clarity:
    
    - +25 asset 명확
        
    - +25 horizon 명확
        
    - +20 direction 명확
        
    - +10 magnitude 수치
        
    - -5 * ambiguities_count
        
- verifiability:
    
    - +40 observables 존재
        
    - +40 falsifiers 존재
        
    - +20 window/metric 명확
        
- consistency:
    
    - 100에서 conflict penalty 차감
        
- actionability:
    
    - +30 roles 구분
        
    - +30 measurable mapping 가능
        
    - +20 asset_class 명확
        
    - +20 data_available
        

> 숫자는 policy로 관리(“scenario_quality_v1”)하고 추후 튜닝 가능.

---

## 5) 게이트(결격) 조건(Gates)

policy.gates에 따라 passed 여부 결정.

권장 결격:

- require_asset=true인데 assets가 모두 unknown → FAIL (`GATE_ASSET_MISSING`)
    
- require_horizon=true인데 horizon unknown → FAIL (`GATE_HORIZON_MISSING`)
    
- require_observable_or_falsifier=true인데 둘 다 없음 → FAIL (`GATE_NOT_FALSIFIABLE`)
    
- ambiguities > max_ambiguities → FAIL 또는 WARN+stress_only(정책)
    

---

## 6) integration_policy_hint 생성 규칙

Quality 결과에 따라 “반영 강도”를 추천한다.

- overall >= 80 and verifiability >= 70:
    
    - mode = `soft` (가중치 cap 높게, 예: 0.6)
        
- 60~79:
    
    - mode = `soft` (cap 낮게, 예: 0.3~0.5)
        
- 40~59:
    
    - mode = `stress_only` (전략 생성엔 직접 반영 X, 스트레스 테스트만)
        
- <40 또는 gate fail:
    
    - mode = `block` (추가 입력 요구)
        

---

## 7) 저장/로그(Observability)

- Document Store(MOD-461):
    
    - `SCENARIO_EVAL_JSON` 저장
        
- Local DB(MOD-460 확장):
    
    - `scenario_evals` 테이블:
        
        - scenario_id, overall_score, sub_scores_json, passed, mode, created_at
            

로그 이벤트:

- `SCENARIO_QUALITY_SCORED`
    
- `SCENARIO_QUALITY_GATE_FAILED`
    

---

## 8) 예외/에러 처리

- `SCHEMA_INVALID`: parsed_scenario 스키마 위반 → FAIL
    
- `MISSING_REQUIRED_FIELD`: hypothesis 누락 → FAIL
    
- `UNKNOWN_METRIC_FIELD`: observables에 지원하지 않는 field → WARN + verifiability 감점
    

---

## 9) 테스트 요구사항

1. asset/horizon/observable 누락 시 gate fail 되는지
    
2. falsifier가 있을 때 verifiability가 상승하는지
    
3. ambiguities가 늘면 clarity 점수가 감소하는지
    
4. overall 점수에 따라 integration_policy_hint mode가 바뀌는지
    
5. 동일 입력이면 동일 점수(결정성)
    

---
